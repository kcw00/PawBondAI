from fastapi import APIRouter, HTTPException, Path, Query, Body, UploadFile, File
from typing import List, Optional
from datetime import datetime
import uuid
import csv
import io

from app.models.schemas import ApplicationCreate, ApplicationResponse
from app.models.es_documents import Application
from app.services.elasticsearch_client import es_client
from app.services.vertex_ai_service import vertex_ai_service
from app.core.config import get_settings
from app.core.logger import setup_logger
from elasticsearch.dsl import AsyncSearch, Q

settings = get_settings()
router = APIRouter()
logger = setup_logger(__name__)


# 1. Create an application
@router.post("", response_model=ApplicationResponse)
async def create_application(application: ApplicationCreate = Body(...)):
    """Create a new foster/adoption application with semantic embedding"""
    application_id = str(uuid.uuid4())

    try:
        # Create AsyncDocument instance
        doc = Application(meta={'id': application_id})

        # Applicant Information
        doc.applicant_name = application.applicant_name
        doc.email = application.email
        doc.phone = application.phone

        # Housing
        doc.housing_type = application.housing_type
        doc.has_yard = application.has_yard
        doc.yard_fenced = application.yard_fenced
        doc.living_space_sqft = application.living_space_sqft
        doc.owns_or_rents = application.owns_or_rents
        doc.landlord_approval = application.landlord_approval

        # Household
        doc.household_adults = application.household_adults
        doc.household_children = application.household_children
        doc.children_ages = application.children_ages
        doc.has_other_pets = application.has_other_pets
        doc.other_pets_details = application.other_pets_details

        # Experience
        doc.dog_experience_level = application.dog_experience_level
        doc.previous_rescue_experience = application.previous_rescue_experience
        doc.special_needs_experience = application.special_needs_experience
        doc.special_needs_types = application.special_needs_types
        doc.work_schedule = application.work_schedule
        doc.hours_alone_per_day = application.hours_alone_per_day
        doc.exercise_commitment = application.exercise_commitment
        doc.training_commitment = application.training_commitment

        # Financial
        doc.monthly_budget = application.monthly_budget
        doc.emergency_vet_fund = application.emergency_vet_fund
        doc.pet_insurance = application.pet_insurance

        # Motivation - embedding auto-generated by ES inference endpoint
        doc.motivation_essay = application.motivation_essay
        doc.motivation_embedding = application.motivation_essay  # ES will generate embedding
        doc.application_type = application.application_type
        doc.preferred_dog_age = application.preferred_dog_age
        doc.preferred_dog_size = application.preferred_dog_size
        doc.preferred_energy_level = application.preferred_energy_level

        # References
        doc.vet_reference = application.vet_reference
        doc.personal_references = application.personal_references
        doc.home_visit_completed = application.home_visit_completed
        doc.home_visit_date = application.home_visit_date
        doc.background_check_status = application.background_check_status

        # Status
        doc.application_status = application.application_status
        doc.submitted_date = datetime.now()

        # Save using AsyncDocument
        await doc.save(using=es_client.client)

        logger.info(f"Application created with ID: {application_id}")

        return ApplicationResponse(
            id=application_id,
            submitted_date=doc.submitted_date,
            created_at=doc.created_at,
            updated_at=doc.updated_at,
            **application.model_dump()
        )
    except Exception as e:
        logger.error(f"Error creating application: {e}")
        raise HTTPException(status_code=500, detail=f"Error creating application: {str(e)}")


# 2. Get an application by ID
@router.get("/{application_id}", response_model=ApplicationResponse)
async def get_application(application_id: str):
    """Get an application by ID"""
    try:
        doc = await Application.get(id=application_id, using=es_client.client)

        return ApplicationResponse(
            id=application_id,
            applicant_name=doc.applicant_name,
            email=doc.email,
            phone=doc.phone,
            housing_type=doc.housing_type,
            has_yard=doc.has_yard,
            yard_fenced=doc.yard_fenced,
            living_space_sqft=doc.living_space_sqft,
            owns_or_rents=doc.owns_or_rents,
            landlord_approval=doc.landlord_approval,
            household_adults=doc.household_adults,
            household_children=doc.household_children,
            children_ages=doc.children_ages or [],
            has_other_pets=doc.has_other_pets,
            other_pets_details=doc.other_pets_details,
            dog_experience_level=doc.dog_experience_level,
            previous_rescue_experience=doc.previous_rescue_experience,
            special_needs_experience=doc.special_needs_experience,
            special_needs_types=doc.special_needs_types or [],
            work_schedule=doc.work_schedule,
            hours_alone_per_day=doc.hours_alone_per_day,
            exercise_commitment=doc.exercise_commitment,
            training_commitment=doc.training_commitment,
            monthly_budget=doc.monthly_budget,
            emergency_vet_fund=doc.emergency_vet_fund,
            pet_insurance=doc.pet_insurance,
            motivation_essay=doc.motivation_essay,
            application_type=doc.application_type,
            preferred_dog_age=doc.preferred_dog_age,
            preferred_dog_size=doc.preferred_dog_size,
            preferred_energy_level=doc.preferred_energy_level,
            vet_reference=doc.vet_reference,
            personal_references=doc.personal_references,
            home_visit_completed=doc.home_visit_completed,
            home_visit_date=doc.home_visit_date,
            background_check_status=doc.background_check_status,
            application_status=doc.application_status,
            submitted_date=doc.submitted_date,
            reviewed_date=doc.reviewed_date,
            matched_dog_id=doc.matched_dog_id,
            placement_date=doc.placement_date,
            created_at=doc.created_at,
            updated_at=doc.updated_at,
        )
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"Application not found: {str(e)}")


# 3. List all applications with filters
@router.get("", response_model=List[ApplicationResponse])
async def list_applications(
    limit: int = Query(10, ge=1, le=100),
    offset: int = Query(0, ge=0),
    status: Optional[str] = Query(None, description="Filter by application status"),
    experience_level: Optional[str] = Query(None, description="Filter by experience level"),
):
    """List applications with filters and pagination"""
    try:
        s = AsyncSearch(using=es_client.client, index="applications")
        s = s.query("match_all")

        # Add filters
        if status:
            s = s.filter("term", application_status=status)
        if experience_level:
            s = s.filter("term", dog_experience_level=experience_level)

        # Sort and paginate
        s = s.sort("-submitted_date")
        s = s[offset:offset + limit]

        response = await s.execute()

        applications = []
        for hit in response:
            app_data = hit.to_dict()
            if "id" not in app_data:
                app_data["id"] = hit.meta.id
            applications.append(ApplicationResponse(**app_data))

        return applications
    except Exception as e:
        logger.error(f"Error listing applications: {e}")
        raise HTTPException(status_code=500, detail=f"Error listing applications: {str(e)}")


# 4. Update an application
@router.put("/{application_id}", response_model=ApplicationResponse)
async def update_application(
    application_id: str,
    application: ApplicationCreate = Body(...),
):
    """Update an application"""
    try:
        doc = await Application.get(id=application_id, using=es_client.client)

        # Update all fields (embedding will be auto-regenerated by ES if essay changes)
        doc.applicant_name = application.applicant_name
        doc.email = application.email
        doc.phone = application.phone
        doc.housing_type = application.housing_type
        doc.has_yard = application.has_yard
        doc.yard_fenced = application.yard_fenced
        doc.living_space_sqft = application.living_space_sqft
        doc.owns_or_rents = application.owns_or_rents
        doc.landlord_approval = application.landlord_approval
        doc.household_adults = application.household_adults
        doc.household_children = application.household_children
        doc.children_ages = application.children_ages
        doc.has_other_pets = application.has_other_pets
        doc.other_pets_details = application.other_pets_details
        doc.dog_experience_level = application.dog_experience_level
        doc.previous_rescue_experience = application.previous_rescue_experience
        doc.special_needs_experience = application.special_needs_experience
        doc.special_needs_types = application.special_needs_types
        doc.work_schedule = application.work_schedule
        doc.hours_alone_per_day = application.hours_alone_per_day
        doc.exercise_commitment = application.exercise_commitment
        doc.training_commitment = application.training_commitment
        doc.monthly_budget = application.monthly_budget
        doc.emergency_vet_fund = application.emergency_vet_fund
        doc.pet_insurance = application.pet_insurance
        doc.motivation_essay = application.motivation_essay
        doc.motivation_embedding = application.motivation_essay  # ES will regenerate embedding
        doc.application_type = application.application_type
        doc.preferred_dog_age = application.preferred_dog_age
        doc.preferred_dog_size = application.preferred_dog_size
        doc.preferred_energy_level = application.preferred_energy_level
        doc.vet_reference = application.vet_reference
        doc.personal_references = application.personal_references
        doc.home_visit_completed = application.home_visit_completed
        doc.home_visit_date = application.home_visit_date
        doc.background_check_status = application.background_check_status
        doc.application_status = application.application_status

        await doc.save(using=es_client.client)

        logger.info(f"Application {application_id} updated successfully")

        return ApplicationResponse(
            id=application_id,
            submitted_date=doc.submitted_date,
            reviewed_date=doc.reviewed_date,
            matched_dog_id=doc.matched_dog_id,
            placement_date=doc.placement_date,
            created_at=doc.created_at,
            updated_at=doc.updated_at,
            **application.model_dump()
        )
    except Exception as e:
        logger.error(f"Error updating application: {e}")
        raise HTTPException(status_code=404, detail=f"Application not found: {str(e)}")


# 5. Delete an application
@router.delete("/{application_id}")
async def delete_application(application_id: str):
    """Delete an application"""
    try:
        doc = await Application.get(id=application_id, using=es_client.client)
        await doc.delete(using=es_client.client)

        logger.info(f"Application {application_id} deleted successfully")
        return {"message": "Application deleted successfully", "application_id": application_id}
    except Exception as e:
        logger.error(f"Error deleting application: {e}")
        raise HTTPException(status_code=404, detail=f"Application not found: {str(e)}")


# ==================== CSV BULK UPLOAD ENDPOINTS ====================

# STEP 2: Validate CSV file
@router.post("/csv/validate")
async def validate_csv(file: UploadFile = File(...)):
    """
    Step 2: VALIDATION (automatic)
    - Check file format
    - Validate columns
    - Count rows
    Returns validation results without indexing
    """
    try:
        # Check file extension
        if not file.filename.endswith('.csv'):
            raise HTTPException(status_code=400, detail="File must be a CSV file")

        # Read CSV content
        content = await file.read()
        csv_string = content.decode('utf-8')
        csv_reader = csv.DictReader(io.StringIO(csv_string))

        # Required columns for application data
        required_columns = [
            "applicant_name", "email", "phone",
            "housing_type", "motivation_essay"
        ]

        # Get actual columns from CSV
        fieldnames = csv_reader.fieldnames
        if not fieldnames:
            raise HTTPException(status_code=400, detail="CSV file is empty or has no headers")

        # Check for required columns
        missing_columns = [col for col in required_columns if col not in fieldnames]
        extra_columns = [col for col in fieldnames if col not in required_columns and col]

        # Count rows
        rows = list(csv_reader)
        row_count = len(rows)

        # Validation results
        validation_result = {
            "valid": len(missing_columns) == 0,
            "filename": file.filename,
            "row_count": row_count,
            "column_count": len(fieldnames),
            "columns_found": fieldnames,
            "required_columns": required_columns,
            "missing_columns": missing_columns,
            "extra_columns": extra_columns,
            "errors": [],
            "warnings": []
        }

        # Add errors if validation failed
        if missing_columns:
            validation_result["errors"].append(
                f"Missing required columns: {', '.join(missing_columns)}"
            )

        # Add warnings for extra columns
        if extra_columns:
            validation_result["warnings"].append(
                f"Extra columns found (will be ignored): {', '.join(extra_columns)}"
            )

        if row_count == 0:
            validation_result["errors"].append("CSV file contains no data rows")
            validation_result["valid"] = False

        logger.info(f"Validated CSV: {file.filename} - Valid: {validation_result['valid']}, Rows: {row_count}")

        return validation_result

    except UnicodeDecodeError:
        raise HTTPException(status_code=400, detail="File encoding error. Please ensure the file is UTF-8 encoded")
    except csv.Error as e:
        raise HTTPException(status_code=400, detail=f"CSV parsing error: {str(e)}")
    except Exception as e:
        logger.error(f"Error validating CSV: {e}")
        raise HTTPException(status_code=500, detail=f"Error validating CSV: {str(e)}")


# STEP 3: Preview CSV data
@router.post("/csv/preview")
async def preview_csv(file: UploadFile = File(...)):
    """
    Step 3: PREVIEW MODAL (requires user confirmation)
    - Show first 5 rows
    - Display validation results
    User will click "Upload & Index" button to proceed to Step 4
    """
    try:
        # Read CSV content
        content = await file.read()
        csv_string = content.decode('utf-8')

        # Validate
        csv_reader = csv.DictReader(io.StringIO(csv_string))
        fieldnames = csv_reader.fieldnames

        required_columns = [
            "applicant_name", "email", "phone",
            "housing_type", "motivation_essay"
        ]

        missing_columns = [col for col in required_columns if col not in fieldnames]
        rows = list(csv_reader)

        validation_result = {
            "valid": len(missing_columns) == 0 and len(rows) > 0,
            "filename": file.filename,
            "row_count": len(rows),
            "missing_columns": missing_columns,
        }

        # Get first 5 rows for preview
        preview_rows = rows[:5]

        return {
            "validation": validation_result,
            "preview_rows": preview_rows,
            "total_rows": len(rows),
            "message": "Review the data below. Click 'Upload & Index' to proceed with indexing."
        }

    except Exception as e:
        logger.error(f"Error previewing CSV: {e}")
        raise HTTPException(status_code=500, detail=f"Error previewing CSV: {str(e)}")


# STEP 4: Upload and Index CSV (requires confirmation)
@router.post("/csv/upload")
async def upload_and_index_csv(file: UploadFile = File(...)):
    """
    Step 4: INDEXING (automatic after user confirmation)
    - Parse CSV data
    - Generate embeddings (via ES inference endpoint)
    - Index to Elasticsearch
    Returns summary of indexed applications
    """
    try:
        # Read and parse CSV
        content = await file.read()
        csv_string = content.decode('utf-8')
        csv_reader = csv.DictReader(io.StringIO(csv_string))
        rows = list(csv_reader)

        indexed_count = 0
        failed_count = 0
        errors = []
        indexed_ids = []

        for idx, row in enumerate(rows):
            try:
                application_id = str(uuid.uuid4())

                # Create AsyncDocument instance
                doc = Application(meta={'id': application_id})

                # Applicant Information
                doc.applicant_name = row.get('applicant_name', '')
                doc.email = row.get('email', '')
                doc.phone = row.get('phone', '')

                # Housing
                doc.housing_type = row.get('housing_type', '')
                doc.has_yard = row.get('has_yard', '').lower() in ['true', 'yes', '1']
                doc.yard_fenced = row.get('yard_fenced', '').lower() in ['true', 'yes', '1']
                doc.living_space_sqft = float(row.get('living_space_sqft', 0)) if row.get('living_space_sqft') else None
                doc.owns_or_rents = row.get('owns_or_rents', '')
                doc.landlord_approval = row.get('landlord_approval', '').lower() in ['true', 'yes', '1']

                # Household
                doc.household_adults = int(row.get('household_adults', 1)) if row.get('household_adults') else 1
                doc.household_children = int(row.get('household_children', 0)) if row.get('household_children') else 0
                doc.children_ages = []
                doc.has_other_pets = row.get('has_other_pets', '').lower() in ['true', 'yes', '1']
                doc.other_pets_details = row.get('other_pets_details', '')

                # Experience
                doc.dog_experience_level = row.get('dog_experience_level', 'Beginner')
                doc.previous_rescue_experience = row.get('previous_rescue_experience', '').lower() in ['true', 'yes', '1']
                doc.special_needs_experience = row.get('special_needs_experience', '').lower() in ['true', 'yes', '1']
                doc.special_needs_types = []
                doc.work_schedule = row.get('work_schedule', '')
                doc.hours_alone_per_day = float(row.get('hours_alone_per_day', 0)) if row.get('hours_alone_per_day') else None
                doc.exercise_commitment = row.get('exercise_commitment', '')
                doc.training_commitment = row.get('training_commitment', '')

                # Financial
                doc.monthly_budget = float(row.get('monthly_budget', 0)) if row.get('monthly_budget') else None
                doc.emergency_vet_fund = row.get('emergency_vet_fund', '').lower() in ['true', 'yes', '1']
                doc.pet_insurance = row.get('pet_insurance', '').lower() in ['true', 'yes', '1']

                # Motivation - ES will auto-generate embedding
                doc.motivation_essay = row.get('motivation_essay', '')
                doc.motivation_embedding = row.get('motivation_essay', '')  # ES will generate embedding
                doc.application_type = row.get('application_type', 'Adoption')
                doc.preferred_dog_age = row.get('preferred_dog_age', '')
                doc.preferred_dog_size = row.get('preferred_dog_size', '')
                doc.preferred_energy_level = row.get('preferred_energy_level', '')

                # References
                doc.vet_reference = row.get('vet_reference', '')
                doc.personal_references = []
                doc.home_visit_completed = row.get('home_visit_completed', '').lower() in ['true', 'yes', '1']
                doc.home_visit_date = None
                doc.background_check_status = row.get('background_check_status', 'Pending')

                # Status
                doc.application_status = row.get('application_status', 'Pending')
                doc.submitted_date = datetime.now()

                # Save to Elasticsearch
                await doc.save(using=es_client.client)

                indexed_count += 1
                indexed_ids.append(application_id)
                logger.info(f"Indexed application {application_id} from CSV row {idx + 1}")

            except Exception as e:
                failed_count += 1
                error_msg = f"Row {idx + 1}: {str(e)}"
                errors.append(error_msg)
                logger.error(f"Error indexing row {idx + 1}: {e}")

        # Return summary
        return {
            "success": True,
            "filename": file.filename,
            "total_rows": len(rows),
            "indexed_count": indexed_count,
            "failed_count": failed_count,
            "indexed_ids": indexed_ids[:10],  # Return first 10 IDs
            "errors": errors[:5],  # Return first 5 errors
            "message": f"Successfully indexed {indexed_count} out of {len(rows)} applications"
        }

    except Exception as e:
        logger.error(f"Error uploading CSV: {e}")
        raise HTTPException(status_code=500, detail=f"Error uploading CSV: {str(e)}")
